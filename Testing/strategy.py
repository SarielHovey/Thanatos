from abc import ABCMeta, abstractmethod
from datetime import datetime as dt
try:
    import Queue as queue
except ImportError:
    import queue

import numpy as np
import pandas as pd
from event import SignalEvent

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for all subsequent (inherited) strategy handling objects.
    The goal of a (derived) Strategy object is to generate Signal objects for particular symbols based on the inputs of Bars (OHLCV) generated by a DataHandler object.
    This is designed to work both with historic and live data as the Strategy object is agnostic to where the data came from, since it obtains the bar tuples from a queue object.
    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Abstract method supports no implement.")

class MovingAverageCrossStrategy(Strategy):
    """
    Carries out a basic Moving Average Crossover strategy with a short/long simple weighted moving average. Default short/long windows are 30/120 periods respectively.
    """
    def __init__(self, bars, events, short_window=30, long_window=120):
        """
        Initialises the Moving Average Cross Strategy.

        Parameters: 
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        short_window - The short moving average lookback.
        long_window - The long moving average lookback.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.short_window = short_window
        self.long_window = long_window

        # Set to True if a symbol is in the market
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols and sets them to 'OUT'.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = 'OUT'
        return bought

    def calculate_signals(self, event):
        """
        Generates a new set of signals based on the MAC SMA with the short window crossing the long window meaning a long entry and vice versa for a short entry.

        Parameters
        event - A MarketEvent object.
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars_values(s, "adj_close", N=self.long_window)
                bar_date = self.bars.get_latest_bar_datetime(s)
                if bars is not None and bars != []:
                    short_sma = np.mean(bars[-self.short_window:])
                    long_sma = np.mean(bars[-self.long_window:])

                    symbol = s
                    cur_date = dt.utcnow()
                    sig_dir = ""

                    if short_sma > long_sma and self.bought[s] == "OUT":
                        print("LONG: %s" % bar_date)
                        sig_dir = 'LONG'
                        signal = SignalEvent(strategy_id=1, symbol=symbol, datetime=cur_date, signal_type=sig_dir, strength=1.0)
                        self.events.put(signal)
                        self.bought[s] = 'LONG'
                    elif short_sma < long_sma and self.bought[s] == "LONG":
                        print("SHORT: %s" % bar_date)
                        sig_dir = 'EXIT'
                        signal = SignalEvent(strategy_id=1, symbol=symbol, datetime=cur_date, signal_type=sig_dir, strength=1.0)
                        self.events.put(signal)
                        self.bought[s] = 'OUT'
